
             ---===[ Qubes Security Bulletin 089 ]===---

                             2023-05-TODO

       Qrexec: Memory corruption in service request handling

User action required
---------------------

Users must install the following specific packages in order to address
the issues discussed in this bulletin:

  For Qubes 4.1, in dom0:
  - qrexec packages version TODO

These packages will migrate from the security-testing repository to the
current (stable) repository over the next two weeks after being tested
by the community. [1] Once available, the packages are to be installed
via the Qubes Update tool or its command-line equivalents. [2]

Summary
--------

Due to a bug in qrexec [3], a malicious qube can cause a memory
corruption in a qrexec-daemon. The Qubes Security Team is not aware of
any method to leverage it into any attack (including even just
crashing the process), but also we cannot completely rule out such
possibility.

Impact
-------

While we consider successful exploitation of the bug very unlikely,
an attacker could potentially use this vulnerability to crash the
qrexec-daemon or execute arbitrary code in dom0.


Discussion
-----------

Qubes OS features a framework known as "qrexec," which allows different
qubes to communicate with each other in a controlled manner. [3][4]
These interactions are restricted by the system's RPC policies. [5] In
particular, qrexec can be used to allow less trusted qubes to
communicate with more trusted qubes, including dom0.

The incoming RPC calls are handled by the qrexec-daemon process.
Qrexec in Qubes OS 4.1 introduced new message type
`MSG_TRIGGER_SERVICE3` allowing much larger request (theoretically up
to 65000 bytes, compared to 64 bytes in earlier versions). This
message type uses dynamically allocated buffer for the message body,
based on the request length. The code used to validate the request
length has an off-by-one error that can cause a memory corruption
described below.

First, the incoming message is validated in the
`sanitize_message_from_agent()` function:

    1177 static void sanitize_message_from_agent(struct msg_header *untrusted_header)
    1178 {
    1179     switch (untrusted_header->type) {
    ...
    1191         case MSG_TRIGGER_SERVICE3:
    1192             if (protocol_version < QREXEC_PROTOCOL_V3) {
    1193                 LOG(ERROR, "agent sent (new) MSG_TRIGGER_SERVICE3 "
    1194                     "although it uses protocol %d", protocol_version);
    1195                 exit(1);
    1196             }
    1197             if (untrusted_header->len < sizeof(struct trigger_service_params3)) {
    1198                 LOG(ERROR, "agent sent invalid MSG_TRIGGER_SERVICE3 packet");
    1199                 exit(1);
    1200             }
    1201             if (untrusted_header->len - sizeof(struct trigger_service_params3)
    1202                     > MAX_SERVICE_NAME_LEN) {
    1203                 LOG(ERROR, "agent sent too large MSG_TRIGGER_SERVICE3 packet");
    1204                 exit(1);
    1205             }
    1206             break;
    ...

The second condition, on line 1197, verifies if the message sent by
the qrexec-agent (from a VM) is not shorter than the message header
defined in `struct trigger_service_params3`. But it fails to account
for a mandatory NUL character at the end of the message payload (the
service name and its argument). Later on, the
`handle_message_from_agent()` function processes the message as
follows:

    1222 static void handle_message_from_agent(void)
    1223 {
    1224     struct msg_header hdr, untrusted_hdr;
    1225     struct trigger_service_params untrusted_params, params;
    1226     struct trigger_service_params3 untrusted_params3, params3;
    1227     char *untrusted_service_name = NULL, *service_name = NULL;
    1228     size_t service_name_len;
    1229
    1230     if (libvchan_recv(vchan, &untrusted_hdr, sizeof(untrusted_hdr))
    1231             != sizeof(untrusted_hdr))
    1232         handle_vchan_error("recv hdr");
    1233     /* sanitize start */
    1234     sanitize_message_from_agent(&untrusted_hdr);
    1235     hdr = untrusted_hdr;
    1236     /* sanitize end */
    ...
    1241     switch (hdr.type) {
    ...
    1262         case MSG_TRIGGER_SERVICE3:
    1263             service_name_len = hdr.len - sizeof(untrusted_params3);
    1264             untrusted_service_name = malloc(service_name_len);
    1265             if (!untrusted_service_name)
    1266                 handle_vchan_error("malloc(service_name)");
    1267
    1268             if (libvchan_recv(vchan, &untrusted_params3, sizeof(untrusted_params3))
    1269                     != sizeof(untrusted_params3))
    1270                 handle_vchan_error("recv params3");
    1271             if (libvchan_recv(vchan, untrusted_service_name, service_name_len)
    1272                     != (int)service_name_len)
    1273                 handle_vchan_error("recv params3(service_name)");
    1274
    1275             /* sanitize start */
    1276             ENSURE_NULL_TERMINATED(untrusted_params3.target_domain);
    1277             ENSURE_NULL_TERMINATED(untrusted_params3.request_id.ident);
    1278             untrusted_service_name[service_name_len-1] = 0;
    1279             sanitize_name(untrusted_params3.target_domain, "@:");
    1280             sanitize_name(untrusted_params3.request_id.ident, " ");
    1281             sanitize_name(untrusted_service_name, "+");
    1282             params3 = untrusted_params3;
    1283             service_name = untrusted_service_name;
    1284             untrusted_service_name = NULL;
    1285             /* sanitize end */
    ...

The initial call to the `sanitize_message_from_agent()` is visible in
line 1234. Then, the function calculates expected service name length in
line 1263, allocates memory for it in line 1264 and receives both the
rest of the header and its payload in lines 1268-1273. Since
`sanitize_message_from_agent()` allows the `hdr.len` to be equal to
`sizeof(untrusted_params3)`, `service_name_len` may be zero. This
means that adding terminating NUL character in line 1278 may write
outside of the allocated buffer. Furthermore in such a case, the
`untrusted_service_name` buffer is allocated with size of zero and the
`sanitize_name()` call in line 1281 may write beyond that buffer too.

The `sanitize_name()` function, listed below, will replace not allowed
characters with underscore (byte 0x5f), until it finds the terminating
NUL character:

    759 static void sanitize_name(char * untrusted_s_signed, char *extra_allowed_chars)
    760 {
    761     unsigned char * untrusted_s;
    762     for (untrusted_s=(unsigned char*)untrusted_s_signed; *untrusted_s; untrusted_s++) {
    763         if (*untrusted_s >= 'a' && *untrusted_s <= 'z')
    764             continue;
    765         if (*untrusted_s >= 'A' && *untrusted_s <= 'Z')
    766             continue;
    767         if (*untrusted_s >= '0' && *untrusted_s <= '9')
    768             continue;
    769         if (*untrusted_s == '_' ||
    770                *untrusted_s == '-' ||
    771                *untrusted_s == '.')
    772             continue;
    773         if (extra_allowed_chars && strchr(extra_allowed_chars, *untrusted_s))
    774             continue;
    775         *untrusted_s = '_';
    776     }
    777 }

Given this code is running in dom0, that in Qubes OS 4.1 is based on
Fedora 32 x86_64, the below analysis will consider behavior of the
standard library used there - GNU libc 2.31. In this
implementation[5], the `malloc()` call (line 1264) will always
allocate at least 32 bytes, even if the requested size is 0. This
means the returned pointer is not NULL in this case (which would be
allowed by the specification for zero-sized allocation), so the error
handling in line 1266 does not interrupt the processing. Then, the
writing of NUL character in line 1278 hits part of the malloc
metadata, specifically the most significant byte of the allocation
size. Given the size is small (between 32 bytes - `MIN_CHUNK_SIZE` and
1024 bytes - `MIN_LARGE_SIZE`), that byte is always zero already, so
this write is harmless.
Remaining concern is about the `sanitize_name()` function. For the bug
to be harmful, it must overwrite something beyond the allocated buffer
(at least 32 bytes). It means, there must be no zero byte in this
area. Our analysis this is very unlikely to be possible due to the
following factors:

1. The malloc() call in handle_message_from_agent() is literally the
only call that happens after startup and connection setup. No other
malloc call happens in that process, not even indirect one (maybe with
exception of handling error message just before exit(1) - but if
attacker hasn't corrupted malloc metadata before, it won't have a chance
to do that after this point either).

2. qrexec-daemon handles only a single request at a time, at no point
multiple buffers for service_name are allocated in the process at the
same time. All remaining handling happens in separate process (which
also handles only a single request).

3. Due to how GNU libc's malloc works, if there is a small chunk available,
it will be used. It won't be split out of a bigger chunk. And due to the
point 2 above, if there was a small chunk initially, it will get
used again.

4. The allocations done during startup leave a few free small chunks
that are interleaved with allocated areas (libvchan_t structure,
something from libxengnttab, libxentoollog and few more). Those memory
chunks can't be merged due to their layout.

5. Every small allocation includes NUL byte somewhere in the payload
before being freed. This applies to both those initial areas, and also
buffers used for service_name.

Given the above, using the issue to successfully perform an attack is
very unlikely. But also, due to complexity of memory allocator, we
cannot completely rule out such possibility.


Credits
--------

This issue was discovered by Demi Marie Obenour.

References
-----------

[1] https://www.qubes-os.org/doc/testing/
[2] https://www.qubes-os.org/doc/how-to-update/
[3] https://www.qubes-os.org/doc/qrexec/
[4] https://www.qubes-os.org/doc/qrexec-internals/
[5] https://sourceware.org/glibc/wiki/MallocInternals

--
The Qubes Security Team
https://www.qubes-os.org/security/
